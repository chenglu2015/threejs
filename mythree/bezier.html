<!DOCTYPE html>

<html>
	<head>
		<title>Bezier Surface</title>
		<script type="text/javascript" src="./libs/three.js"></script>
		<script type="text/javascript" src="./libs/jquery-1.9.0.js"></script>
		<script type="text/javascript" src="./libs/stats.js"></script>
		<script type="text/javascript" src="./libs/dat.gui.js"></script>
		<script type="text/javascript" src="./libs/TrackballControls.js"></script>
		<script type="text/javascript" src="./js/PlaneControls.js"></script>
		<script type="text/javascript" src="./js/BezierSurface.js"></script>
		<script type="text/javascript" src="./js/ParticleMaterial.js"></script>
		<style >
			body{
				/* set margin to 0 and overflow to hidden, to use the complete page */

				margin: 0;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<!-- Div which will hold the Output -->
		<div id="WebGL-output">
		</div>

		<!-- Div which will show the stats -->
		<div id="Stats-output">
		</div>

		<script type="x-shader/x-vertex" id="vertexshader">

			attribute float size;
			attribute vec3 customColor;

			varying vec3 vColor;

			void main() {

				vColor = customColor;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform vec3 color;
			uniform sampler2D texture;

			varying vec3 vColor;

			void main() {

				gl_FragColor = vec4( color * vColor, 1.0 );

				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );

			}

		</script>


		<!-- Javascript code that runs our Three.js examples -->
		<script type="text/javascript">

			var mouse = new THREE.Vector2();
			//camera move
			var planeControls;

			var uniforms;

			//once everything is loaded, we run our Three.js stuff.
			$(function () { 
 				var stats = initStats();
 				
 				//here we'll put the Three.js stuff
 				var scene = new THREE.Scene();
 				
 				//add camera and renderer
 				var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
 				
 				var renderer = new THREE.WebGLRenderer();
 				renderer.setClearColor(0x111111, 1.0);
 				renderer.setSize(window.innerWidth, window.innerHeight);
 				renderer.shadowMapEnabled = true;

		        document.getElementById("WebGL-output").appendChild(renderer.domElement);

		        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		        window.addEventListener( 'resize', onWindowResize, false );

		        //trackball
		        trackball = new THREE.TrackballControls(camera);
				trackball.rotateSpeed = 0.005;
				trackball.zoomSpeed = 1;
				trackball.panSpeed = 1;
				//planeControls
				camera.position.x = 200;
		        camera.position.y = 100;
		        camera.position.z = 200;
				planeControls = new THREE.PlaneControls(camera, new THREE.Vector3(200, 100, 0), renderer.domElement);


		        //bezier surfaces
		        var m = 50, n = 50;
		        var segment = 100;
		        var range = 100;
		        var roll = 10;
		        var p = [];
		        for(var i = 0; i <= m; i++){
		        	p[i] = [];
		        	for(var j = 0; j <= n; j++){
		        		var k = -range / 2 + Math.floor(range * Math.random());
		        		p[i][j] = new THREE.Vector3(2 * i * 10, k * 10, -2 * j * 10);
		        	}
		        }

	            //another particle system
	   			var attributes = {

					size:        { type: 'f', value: null },
					customColor: { type: 'c', value: null }

				};

				uniforms = {

					color:     { type: "c", value: new THREE.Color( 0xffffff ) },
					texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "./image/lensflare4.jpg" ) }

				};

				var shaderMaterial = new THREE.ShaderMaterial( {

					uniforms:       uniforms,
					attributes:     attributes,
					vertexShader:   document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

					blending:       THREE.AdditiveBlending,
					depthTest:      false,
					transparent:    true

				});


		 		var radius = 200;
		 		var psize = 10;
		 		var particles = 10000;

				var geometry = new THREE.BufferGeometry();

				var positions = new Float32Array( particles * 3 );
				var colors = new Float32Array( particles * 3 );
				var sizes = new Float32Array( particles );

				var count = 0;
				for(var i = 0; i < segment; i++){
		        	var u = i / segment;
		        	for(var j = 0; j < segment; j++){
		        		var v = j / segment;
		        		var particle = getBezierSurfacePoint(u, v, m, n, p);
		        		particle.x += - roll / 2 + roll * Math.random();
		        		particle.y += - roll / 2 + roll * Math.random();
		        		particle.z += - roll / 2 + roll * Math.random();

		        		positions[ count * 3 + 0 ] = particle.x;
						positions[ count * 3 + 1 ] = particle.y;
						positions[ count * 3 + 2 ] = particle.z;

						var color = new THREE.Color();
						color.setHSL( 6000 / particles, 1.0, 0.5 );

						colors[ count * 3 + 0 ] = color.r;
						colors[ count * 3 + 1 ] = color.g;
						colors[ count * 3 + 2 ] = color.b;

						sizes[ count ] = 2 * psize;
						count ++;

		        	}
		        }

				// for ( var i = 0, i3 = 0; i < particles; i ++, i3 += 3 ) {

				// 	positions[ i3 + 0 ] = ( Math.random() * 2 - 1 ) * radius;
				// 	positions[ i3 + 1 ] = ( Math.random() * 2 - 1 ) * radius;
				// 	positions[ i3 + 2 ] = ( Math.random() * 2 - 1 ) * radius;

				// 	var color = new THREE.Color();
				// 	color.setHSL( 6000 / particles, 1.0, 0.5 );

				// 	colors[ i3 + 0 ] = color.r;
				// 	colors[ i3 + 1 ] = color.g;
				// 	colors[ i3 + 2 ] = color.b;

				// 	sizes[ i ] = 2 * psize;

				// }

				geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
				geometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );

				var particleSystem = new THREE.PointCloud( geometry, shaderMaterial );

				scene.add( particleSystem );

 				//add animation
 				render();
 				function render(){
 					stats.update();

 					planeControls.update();

 					var time = Date.now() * 0.001;

 					var sizes = geometry.attributes.size.array;

					for ( var i = 0; i < particles; i++ ) {

						sizes[ i ] = psize * ( 1 + Math.abs(Math.sin( 0.1 * i + time )) );

					}

					geometry.attributes.size.needsUpdate = true;

 					requestAnimationFrame(render);
 					renderer.render(scene, camera);
 				};

 				function onWindowResize() {

					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

					renderer.setSize( window.innerWidth, window.innerHeight );

				}

				function onDocumentMouseMove( event ) {

					event.preventDefault();

					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				}

			});

			function initStats(){
				var stats = new Stats();
				stats.setMode(0);
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.lefe = '0px';
				stats.domElement.style.top = '0px';
				$("#Stats-output").append(stats.domElement);
				return stats;
			}

	        

      		


		</script>

	</body>
</html>