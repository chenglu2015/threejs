<!DOCTYPE html>

<html>
	<head>
		<title>Move Point</title>
		<script type="text/javascript" src="./libs/three.js"></script>
		<script type="text/javascript" src="./libs/jquery-1.9.0.js"></script>
		<script type="text/javascript" src="./libs/stats.js"></script>
		<script type="text/javascript" src="./libs/dat.gui.js"></script>
		<script type="text/javascript" src="./libs/controls/OrbitControls.js"></script>
		<style >
			body{
				/* set margin to 0 and overflow to hidden, to use the complete page */

				margin: 0;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<!-- Div which will hold the Output -->
		<div id="WebGL-output">
		</div>

		<!-- Div which will show the stats -->
		<div id="Stats-output">
		</div>

		<!-- Javascript code that runs our Three.js examples -->
		<script type="text/javascript">

			var controls;

			//raycaster and intersects
			var raycaster = new THREE.Raycaster();
			var SELECTED, INTERSECTED;
			var offset = new THREE.Vector3();
			var mouse = new THREE.Vector2();  //mouse position


			//once everything is loaded, we run our Three.js stuff.
			$(function () { 
 				var stats = initStats();
 				
 				//here we'll put the Three.js stuff
 				var scene = new THREE.Scene();
 				
 				//add camera and renderer
 				var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
 				
 				var renderer = new THREE.WebGLRenderer();
 				renderer.setClearColor(0xEEEEEE, 1.0);
 				renderer.setSize(window.innerWidth, window.innerHeight);
 				renderer.shadowMapEnabled = true;

 				//add Light
 				var ambientLight = new THREE.AmbientLight(0x0a0a0a);
 				scene.add(ambientLight);

 				var spotLight = new THREE.SpotLight(0xffffff);
 				spotLight.castShadow = true;
 				spotLight.position.set(-40, 60, -10);
 				scene.add(spotLight);

 				//add plane
 				plane = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( 2000, 2000, 8, 8 ),
					new THREE.MeshBasicMaterial( { visible: false } )
				);
				scene.add( plane );
 				// var planeGeo = new THREE.PlaneGeometry(60,40,1,1);
 				// var planeMtr = new THREE.MeshLambertMaterial({color: 0xffffff});
 				// var plane = new THREE.Mesh(planeGeo, planeMtr);
 				// plane.rotation.x = -0.5 * Math.PI;
		   //      plane.position.x = 0;
		   //      plane.position.y = 0;
		   //      plane.position.z = 0;
		   //      plane.receiveShadow = true;
		        // scene.add(plane);

		        camera.position.x = -30;
		        camera.position.y = 30;
		        camera.position.z = 30;
		        camera.lookAt(scene.position);
		        document.getElementById("WebGL-output").appendChild(renderer.domElement);

		        document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		        document.addEventListener( 'mousedown', onDocumentMouseDown, false );
		        document.addEventListener( 'mouseup', onDocumentMouseUp, false );
		        window.addEventListener( 'resize', onWindowResize, false );

		        //add spheres
		        var spheres = [];

		        var radius = 1;
		        var range = 100;
		        var material = new THREE.MeshLambertMaterial({color: 0xaaccff});
		        for(var i = 0; i < 10; i++){
		        	var geom = new THREE.SphereGeometry(radius, 30, 30);
		        	var sphere = new THREE.Mesh(geom, material);
		        	sphere.position.set(range * (Math.random() - 0.5), range * (Math.random() - 0.5), range * (Math.random() - 0.5));
		        	sphere.index = i;
		        	spheres.push(sphere);
		        	scene.add(sphere);
		        }

		        //add lines
		        // var link = [
		        // 	[2, 3],
		        // 	[4],
		        // 	[1, 5],
		        // 	[7, 9],
		        // 	[6, 7, 8],
		        // 	[1, 2, 3],
		        // 	[4, 5],
		        // 	[1, 8],
		        // 	[0, 6],
		        // 	[0]
		        // ];

		        // var lineMaterial = new THREE.LineBasicMaterial({
		        // 	color: 0xffffff,
		        // 	opacity: 1,
		        // 	linewidth: 3,
		        // 	vertexColors: THREE.VertexColors
		        // });

		        // for(var i = 0; i < 10; i++){
		        // 	var linepoint = link[i];

		        // 	var colors = [];
		        // 	var color = new THREE.Color();
		        // 	color.setHSL( i / 10, 1.0, 0.5);
		        // 	colors.push(color);

		        // 	for(var index in linepoint){

		        // 		var geom = new THREE.Geometry();
		        // 		geom.vertices.push(spheres[i].position);
		        // 		geom.vertices.push(spheres[linepoint[index]].position);
		        // 		geom.colors = colors;

		        // 		var line = new THREE.Line(geom, lineMaterial);
		        // 		scene.add(line);
		        // 	}
		        // }

		        var helper = new THREE.GridHelper( 100, 10 );
				helper.material.opacity = 0.25;
				helper.material.transparent = true;
				scene.add( helper );


				//Controls
				controls = new THREE.OrbitControls(camera, renderer.domElement);


 				//add animation
 				render();
 				
 				function render () {

 					stats.update();
 					controls.update();

 					requestAnimationFrame(render);
 					renderer.render(scene, camera);
 				};

 				function onWindowResize() {

					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

					renderer.setSize( window.innerWidth, window.innerHeight );

				}

				function onDocumentMouseMove( event ) {

					event.preventDefault();

					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

					//

					raycaster.setFromCamera( mouse, camera );

					if ( SELECTED ) {

						var intersects = raycaster.intersectObject( plane );

						if ( intersects.length > 0 ) {

							SELECTED.position.copy( intersects[ 0 ].point.sub( offset ) );

						}

						return;

					}

					var intersects = raycaster.intersectObjects( spheres );

					if ( intersects.length > 0 ) {

						if ( INTERSECTED != intersects[ 0 ].object ) {

							if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

							INTERSECTED = intersects[ 0 ].object;
							INTERSECTED.currentHex = INTERSECTED.material.color.getHex();

							plane.position.copy( INTERSECTED.position );
							plane.lookAt( camera.position );

						}

					} else {

						if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

						INTERSECTED = null;

					}

				}

				function onDocumentMouseDown( event ) {

					event.preventDefault();

					raycaster.setFromCamera( mouse, camera );

					var intersects = raycaster.intersectObjects( spheres );

					if ( intersects.length > 0 ) {

						controls.enabled = false;

						SELECTED = intersects[ 0 ].object;

						var intersects = raycaster.intersectObject( plane );

						if ( intersects.length > 0 ) {

							offset.copy( intersects[ 0 ].point ).sub( plane.position );

						}


					}

				}

				function onDocumentMouseUp( event ) {

					event.preventDefault();

					controls.enabled = true;

					if ( INTERSECTED ) {

						plane.position.copy( INTERSECTED.position );

						SELECTED = null;

					}

				}

			});

			function initStats(){
				var stats = new Stats();
				stats.setMode(0);
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.lefe = '0px';
				stats.domElement.style.top = '0px';
				$("#Stats-output").append(stats.domElement);
				return stats;
			}



		</script>

	</body>
</html>